<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libft900: include/ft900_usbdx.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="brtlogo.png"/></td>
  <td id="projectalign">
   <div id="projectname">libft900<span id="projectnumber">&#160;2.7.0</span>
   </div>
   <div id="projectbrief">A hardware abstraction library for the FT9xx</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ft900_usbdx.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>USB Device extended API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for USB Request Block or URB USBDX is based on message passing transactions. The messages are called URBs, which stands for USB request block. URBs are sent by calling the USBDX_submit_urb method, whichs is an asynchronous call, and it returns immediately. .  <a href="struct_u_s_b_d_x__urb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to maintain the pipe related data. A pipe structure is for each endpoint.  <a href="struct_u_s_b_d_x__pipe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2517e30d0cacd938bc09239fdece6b34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a2517e30d0cacd938bc09239fdece6b34">USBDX_NDEBUG</a></td></tr>
<tr class="separator:a2517e30d0cacd938bc09239fdece6b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c15ba32cd4cbd353c91c036fd9582f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a2c15ba32cd4cbd353c91c036fd9582f2">FEATURE_ASSERT_IN_DEBUG_BUILD</a></td></tr>
<tr class="separator:a2c15ba32cd4cbd353c91c036fd9582f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c33b494a68ce28497e7ce8e5e95feff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a>&#160;&#160;&#160;const __flash__</td></tr>
<tr class="separator:a0c33b494a68ce28497e7ce8e5e95feff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3428692efe6051ef30016ffde1a9f7bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a3428692efe6051ef30016ffde1a9f7bb">STRINGIZE</a>(x)&#160;&#160;&#160;#x</td></tr>
<tr class="separator:a3428692efe6051ef30016ffde1a9f7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e42534272f3f6ed1fc5b01e5ab56e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a87e42534272f3f6ed1fc5b01e5ab56e2">INTSTR</a>(x)&#160;&#160;&#160;<a class="el" href="ft900__usbdx_8h.html#a3428692efe6051ef30016ffde1a9f7bb">STRINGIZE</a>(x)</td></tr>
<tr class="separator:a87e42534272f3f6ed1fc5b01e5ab56e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217a0bd562b98ae8c2ffce44935351e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a217a0bd562b98ae8c2ffce44935351e1">likely</a>(x)&#160;&#160;&#160;__builtin_expect(!!(x), 1)</td></tr>
<tr class="separator:a217a0bd562b98ae8c2ffce44935351e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c45889010c1bd68631771b64f18101"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#ac6c45889010c1bd68631771b64f18101">unlikely</a>(x)&#160;&#160;&#160;__builtin_expect(!!(x), 0)</td></tr>
<tr class="separator:ac6c45889010c1bd68631771b64f18101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27cc17b25bb93134368d5eb21126eae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#ad27cc17b25bb93134368d5eb21126eae">BIT</a>(x)&#160;&#160;&#160;(1U &lt;&lt; (x))</td></tr>
<tr class="separator:ad27cc17b25bb93134368d5eb21126eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6242a25f9d996f0cc4f4cdb911218b75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a6242a25f9d996f0cc4f4cdb911218b75">ARRAY_SIZE</a>(x)&#160;&#160;&#160;(sizeof(x)/sizeof((x)[0]))</td></tr>
<tr class="separator:a6242a25f9d996f0cc4f4cdb911218b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c0416272e5c07bdf955d803a21688e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a04c0416272e5c07bdf955d803a21688e">LOBYTE</a>(w)&#160;&#160;&#160;((uint8_t)(w))</td></tr>
<tr class="separator:a04c0416272e5c07bdf955d803a21688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c5b5f21e837e80c0feb4da9a421f87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a75c5b5f21e837e80c0feb4da9a421f87">HIBYTE</a>(w)&#160;&#160;&#160;((uint8_t)(((uint16_t)(w) &gt;&gt; 8) &amp; 0xFF))</td></tr>
<tr class="separator:a75c5b5f21e837e80c0feb4da9a421f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31453f546d9525d262dd9c7814b11e02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a31453f546d9525d262dd9c7814b11e02">NOLOG</a>(x, ...)</td></tr>
<tr class="separator:a31453f546d9525d262dd9c7814b11e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c95a90e7806e4b0d21edfae15b73465"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a3c95a90e7806e4b0d21edfae15b73465">UNUSED_PARAMETER</a>(x)&#160;&#160;&#160;(void)(x)</td></tr>
<tr class="separator:a3c95a90e7806e4b0d21edfae15b73465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b2148696e70297cce6c0f18f48b899"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#ab6b2148696e70297cce6c0f18f48b899">LOGD</a>(x, ...)</td></tr>
<tr class="separator:ab6b2148696e70297cce6c0f18f48b899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54bba0fe6687d2fc07449a290bf94fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#ac54bba0fe6687d2fc07449a290bf94fd">LOGI</a>(x, ...)</td></tr>
<tr class="separator:ac54bba0fe6687d2fc07449a290bf94fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac461850dbd86197e6de9468436b4348"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#aac461850dbd86197e6de9468436b4348">LOGE</a>(x, ...)</td></tr>
<tr class="separator:aac461850dbd86197e6de9468436b4348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbc469eb189fd98eead7ce1691dce53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a7bbc469eb189fd98eead7ce1691dce53">assert</a>(__e)</td></tr>
<tr class="separator:a7bbc469eb189fd98eead7ce1691dce53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:add9df82e61e57ce4950d571941880883"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#add9df82e61e57ce4950d571941880883">USBDX_callback</a>) (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp)</td></tr>
<tr class="separator:add9df82e61e57ce4950d571941880883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0a5444f7d25fd7a46ca71e0bcf45f6fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a0a5444f7d25fd7a46ca71e0bcf45f6fd">USBDX_pipe_init</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, uint8_t id, uint8_t ep, struct <a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a> *urbs, uint8_t *bufs, uint8_t urb_count)</td></tr>
<tr class="memdesc:a0a5444f7d25fd7a46ca71e0bcf45f6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the URB pipe for data transfer.  <a href="ft900__usbdx_8h.html#a0a5444f7d25fd7a46ca71e0bcf45f6fd">More...</a><br /></td></tr>
<tr class="separator:a0a5444f7d25fd7a46ca71e0bcf45f6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Optional functions for registering event callbacks.</div></td></tr>
<tr class="memitem:a7982281df0dec3c78adc2ded6e152c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a7982281df0dec3c78adc2ded6e152c98">USBDX_register_on_ready</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, <a class="el" href="ft900__usbdx_8h.html#add9df82e61e57ce4950d571941880883">USBDX_callback</a> callback)</td></tr>
<tr class="memdesc:a7982281df0dec3c78adc2ded6e152c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">To register callback function for USBD READY event.  <a href="ft900__usbdx_8h.html#a7982281df0dec3c78adc2ded6e152c98">More...</a><br /></td></tr>
<tr class="separator:a7982281df0dec3c78adc2ded6e152c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89093272d9e88675b1a660afc3e1c270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a89093272d9e88675b1a660afc3e1c270">USBDX_register_on_underrun</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, <a class="el" href="ft900__usbdx_8h.html#add9df82e61e57ce4950d571941880883">USBDX_callback</a> callback)</td></tr>
<tr class="memdesc:a89093272d9e88675b1a660afc3e1c270"><td class="mdescLeft">&#160;</td><td class="mdescRight">To register callback function for USDB UNDERRUN event.  <a href="ft900__usbdx_8h.html#a89093272d9e88675b1a660afc3e1c270">More...</a><br /></td></tr>
<tr class="separator:a89093272d9e88675b1a660afc3e1c270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c631177e850d6450f69202e1a084550"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a0c631177e850d6450f69202e1a084550">USBDX_force_acquire_urb_for_app</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp)</td></tr>
<tr class="memdesc:a0c631177e850d6450f69202e1a084550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns a URB.  <a href="ft900__usbdx_8h.html#a0c631177e850d6450f69202e1a084550">More...</a><br /></td></tr>
<tr class="separator:a0c631177e850d6450f69202e1a084550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753728d1b207d43b70a676c2e6670837"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a753728d1b207d43b70a676c2e6670837">USBDX_submit_urb</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, struct <a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a> *urb)</td></tr>
<tr class="memdesc:a753728d1b207d43b70a676c2e6670837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a URB to USBD.  <a href="ft900__usbdx_8h.html#a753728d1b207d43b70a676c2e6670837">More...</a><br /></td></tr>
<tr class="separator:a753728d1b207d43b70a676c2e6670837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2fa39bb6dd7e144fa72d70cf213424"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a8c2fa39bb6dd7e144fa72d70cf213424">USBDX_get_app_urbs</a> (const struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, uint16_t len)</td></tr>
<tr class="memdesc:a8c2fa39bb6dd7e144fa72d70cf213424"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get more than one URBs for application.  <a href="ft900__usbdx_8h.html#a8c2fa39bb6dd7e144fa72d70cf213424">More...</a><br /></td></tr>
<tr class="separator:a8c2fa39bb6dd7e144fa72d70cf213424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013a4bbef771435d3f2b2ebec9fa8643"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a013a4bbef771435d3f2b2ebec9fa8643">USBDX_submit_urbs</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, uint16_t len)</td></tr>
<tr class="memdesc:a013a4bbef771435d3f2b2ebec9fa8643"><td class="mdescLeft">&#160;</td><td class="mdescRight">To submit more than one URBs from application.  <a href="ft900__usbdx_8h.html#a013a4bbef771435d3f2b2ebec9fa8643">More...</a><br /></td></tr>
<tr class="separator:a013a4bbef771435d3f2b2ebec9fa8643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeaa38efaede81c10cdccb73859839f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a6eeaa38efaede81c10cdccb73859839f">USBDX_pipe_process</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp)</td></tr>
<tr class="memdesc:a6eeaa38efaede81c10cdccb73859839f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The given pipe is processed to transfer the data to/from USBD hardware endpoint.  <a href="ft900__usbdx_8h.html#a6eeaa38efaede81c10cdccb73859839f">More...</a><br /></td></tr>
<tr class="separator:a6eeaa38efaede81c10cdccb73859839f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3de006e6c851ea4929881798485ed32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#ae3de006e6c851ea4929881798485ed32">USBDX_pipe_purge</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp)</td></tr>
<tr class="memdesc:ae3de006e6c851ea4929881798485ed32"><td class="mdescLeft">&#160;</td><td class="mdescRight">To flush the pipe.  <a href="ft900__usbdx_8h.html#ae3de006e6c851ea4929881798485ed32">More...</a><br /></td></tr>
<tr class="separator:ae3de006e6c851ea4929881798485ed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad079836e1421efbfa002dcd47fad9958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#ad079836e1421efbfa002dcd47fad9958">USBDX_buf_write</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, void(*buf_write)(uint8_t *usbd, const uint8_t *app, uint16_t len), uint8_t *usbd, const uint8_t *app, uint16_t len)</td></tr>
<tr class="separator:ad079836e1421efbfa002dcd47fad9958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f64e6c9bcc53d7bfe51e34e7a81cff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#ac6f64e6c9bcc53d7bfe51e34e7a81cff">USBDX_buf_read</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, void(*buf_read)(uint8_t *app, const uint8_t *usbd, uint16_t len), uint8_t *app, const uint8_t *usbd, uint16_t len)</td></tr>
<tr class="separator:ac6f64e6c9bcc53d7bfe51e34e7a81cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8b411a24a59d4c7568b91e02236be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a7c8b411a24a59d4c7568b91e02236be0">USBDX_stream_write</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, void(*stream_write)(uint8_t *usbd, const uint8_t *app, uint16_t len), uint8_t *usbd, const uint8_t *app, uint16_t len)</td></tr>
<tr class="separator:a7c8b411a24a59d4c7568b91e02236be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6222c099c5f593681c833b2c35c52ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#aa6222c099c5f593681c833b2c35c52ee">USBDX_stream_read</a> (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp, void(*stream_read)(uint8_t *app, const uint8_t *usbd, uint16_t len), uint8_t *app, const uint8_t *usbd, uint16_t len)</td></tr>
<tr class="separator:aa6222c099c5f593681c833b2c35c52ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4866f18652ee4acb2ca073153bf3dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#aab4866f18652ee4acb2ca073153bf3dd">USBDX_pipe_isr_start</a> (void)</td></tr>
<tr class="memdesc:aab4866f18652ee4acb2ca073153bf3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container function before processing pipes.  <a href="ft900__usbdx_8h.html#aab4866f18652ee4acb2ca073153bf3dd">More...</a><br /></td></tr>
<tr class="separator:aab4866f18652ee4acb2ca073153bf3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3168375907a3ecd2d3da64b4243aae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a8d3168375907a3ecd2d3da64b4243aae">USBDX_pipe_isr_stop</a> (void)</td></tr>
<tr class="memdesc:a8d3168375907a3ecd2d3da64b4243aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container function after processing pipes.  <a href="ft900__usbdx_8h.html#a8d3168375907a3ecd2d3da64b4243aae">More...</a><br /></td></tr>
<tr class="separator:a8d3168375907a3ecd2d3da64b4243aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319ae19b9f42b26d47268ef9be67e81f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ft900__usbdx_8h.html#a319ae19b9f42b26d47268ef9be67e81f">USBDX_pipe_isr</a> (uint16_t pipe_bitfields)</td></tr>
<tr class="memdesc:a319ae19b9f42b26d47268ef9be67e81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous data transfer in USBDX.  <a href="ft900__usbdx_8h.html#a319ae19b9f42b26d47268ef9be67e81f">More...</a><br /></td></tr>
<tr class="separator:a319ae19b9f42b26d47268ef9be67e81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >USB Device extended API. </p>
<p >APIs that provides asynchronous transfer of USB data. USBDX manages buffer, buffer is divided into chunks called USB Request Blocks (URBs) and are marked with ownership as ‘USBD owned’ or ‘Application owned’. USBDX will transfer its owned URB to the USBD ISR, and releases the empty URB(s) back to application (change ownership)</p>
<p >Application can – get owned URB(s) in main loop or another ISR – process URB(s) – queue back URB(s) to USBD (change ownership) </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6242a25f9d996f0cc4f4cdb911218b75" name="a6242a25f9d996f0cc4f4cdb911218b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6242a25f9d996f0cc4f4cdb911218b75">&#9670;&nbsp;</a></span>ARRAY_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARRAY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(x)/sizeof((x)[0]))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bbc469eb189fd98eead7ce1691dce53" name="a7bbc469eb189fd98eead7ce1691dce53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbc469eb189fd98eead7ce1691dce53">&#9670;&nbsp;</a></span>assert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define assert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">__e</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad27cc17b25bb93134368d5eb21126eae" name="ad27cc17b25bb93134368d5eb21126eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27cc17b25bb93134368d5eb21126eae">&#9670;&nbsp;</a></span>BIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(1U &lt;&lt; (x))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c33b494a68ce28497e7ce8e5e95feff" name="a0c33b494a68ce28497e7ce8e5e95feff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c33b494a68ce28497e7ce8e5e95feff">&#9670;&nbsp;</a></span>CONST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONST&#160;&#160;&#160;const __flash__</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c15ba32cd4cbd353c91c036fd9582f2" name="a2c15ba32cd4cbd353c91c036fd9582f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c15ba32cd4cbd353c91c036fd9582f2">&#9670;&nbsp;</a></span>FEATURE_ASSERT_IN_DEBUG_BUILD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FEATURE_ASSERT_IN_DEBUG_BUILD</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75c5b5f21e837e80c0feb4da9a421f87" name="a75c5b5f21e837e80c0feb4da9a421f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c5b5f21e837e80c0feb4da9a421f87">&#9670;&nbsp;</a></span>HIBYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HIBYTE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">w</td><td>)</td>
          <td>&#160;&#160;&#160;((uint8_t)(((uint16_t)(w) &gt;&gt; 8) &amp; 0xFF))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87e42534272f3f6ed1fc5b01e5ab56e2" name="a87e42534272f3f6ed1fc5b01e5ab56e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e42534272f3f6ed1fc5b01e5ab56e2">&#9670;&nbsp;</a></span>INTSTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTSTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ft900__usbdx_8h.html#a3428692efe6051ef30016ffde1a9f7bb">STRINGIZE</a>(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a217a0bd562b98ae8c2ffce44935351e1" name="a217a0bd562b98ae8c2ffce44935351e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217a0bd562b98ae8c2ffce44935351e1">&#9670;&nbsp;</a></span>likely</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define likely</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;__builtin_expect(!!(x), 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04c0416272e5c07bdf955d803a21688e" name="a04c0416272e5c07bdf955d803a21688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c0416272e5c07bdf955d803a21688e">&#9670;&nbsp;</a></span>LOBYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOBYTE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">w</td><td>)</td>
          <td>&#160;&#160;&#160;((uint8_t)(w))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6b2148696e70297cce6c0f18f48b899" name="ab6b2148696e70297cce6c0f18f48b899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b2148696e70297cce6c0f18f48b899">&#9670;&nbsp;</a></span>LOGD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOGD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac461850dbd86197e6de9468436b4348" name="aac461850dbd86197e6de9468436b4348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac461850dbd86197e6de9468436b4348">&#9670;&nbsp;</a></span>LOGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac54bba0fe6687d2fc07449a290bf94fd" name="ac54bba0fe6687d2fc07449a290bf94fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54bba0fe6687d2fc07449a290bf94fd">&#9670;&nbsp;</a></span>LOGI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOGI</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31453f546d9525d262dd9c7814b11e02" name="a31453f546d9525d262dd9c7814b11e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31453f546d9525d262dd9c7814b11e02">&#9670;&nbsp;</a></span>NOLOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NOLOG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3428692efe6051ef30016ffde1a9f7bb" name="a3428692efe6051ef30016ffde1a9f7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3428692efe6051ef30016ffde1a9f7bb">&#9670;&nbsp;</a></span>STRINGIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRINGIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;#x</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6c45889010c1bd68631771b64f18101" name="ac6c45889010c1bd68631771b64f18101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c45889010c1bd68631771b64f18101">&#9670;&nbsp;</a></span>unlikely</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define unlikely</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;__builtin_expect(!!(x), 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c95a90e7806e4b0d21edfae15b73465" name="a3c95a90e7806e4b0d21edfae15b73465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c95a90e7806e4b0d21edfae15b73465">&#9670;&nbsp;</a></span>UNUSED_PARAMETER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNUSED_PARAMETER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(void)(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2517e30d0cacd938bc09239fdece6b34" name="a2517e30d0cacd938bc09239fdece6b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2517e30d0cacd938bc09239fdece6b34">&#9670;&nbsp;</a></span>USBDX_NDEBUG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBDX_NDEBUG</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr  />
 <h1><a class="anchor" id="autotoc_md1"></a>
(C) Copyright Bridgetek Pte Ltd</h1>
<p >This source code ("the Software") is provided by Bridgetek Pte Ltd ("Bridgetek") subject to the licence terms set out <a href="http://www.ftdichip.com/FTSourceCodeLicenceTerms.htm">http://www.ftdichip.com/FTSourceCodeLicenceTerms.htm</a> ("the Licence Terms"). You must read the Licence Terms before downloading or using the Software. By installing or using the Software you agree to the Licence Terms. If you do not agree to the Licence Terms then do not download or use the Software.</p>
<p >Without prejudice to the Licence Terms, here is a summary of some of the key terms of the Licence Terms (and in the event of any conflict between this summary and the Licence Terms then the text of the Licence Terms will prevail).</p>
<p >The Software is provided "as is". There are no warranties (or similar) in relation to the quality of the Software. You use it at your own risk. The Software should not be used in, or for, any medical device, system or appliance. There are exclusions of Bridgetek liability for certain types of loss such as: special loss or damage; incidental loss or damage; indirect or consequential loss or damage; loss of income; loss of business; loss of profits; loss of revenue; loss of contracts; business interruption; loss of the use of money or anticipated savings; loss of information; loss of opportunity; loss of goodwill or reputation; and/or loss of, damage to or corruption of data. There is a monetary cap on Bridgetek's liability. The Software may have subsequently been amended by another user and then distributed by that other user ("Adapted Software"). If so that user may have additional licence terms that apply to those amendments. However, </p>
<h1><a class="anchor" id="autotoc_md2"></a>
Bridgetek has no liability in relation to those amendments.</h1>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="add9df82e61e57ce4950d571941880883" name="add9df82e61e57ce4950d571941880883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9df82e61e57ce4950d571941880883">&#9670;&nbsp;</a></span>USBDX_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* USBDX_callback) (struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *pp)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac6f64e6c9bcc53d7bfe51e34e7a81cff" name="ac6f64e6c9bcc53d7bfe51e34e7a81cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f64e6c9bcc53d7bfe51e34e7a81cff">&#9670;&nbsp;</a></span>USBDX_buf_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_buf_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint8_t *app, const uint8_t *usbd, uint16_t len)&#160;</td>
          <td class="paramname"><em>buf_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>usbd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad079836e1421efbfa002dcd47fad9958" name="ad079836e1421efbfa002dcd47fad9958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad079836e1421efbfa002dcd47fad9958">&#9670;&nbsp;</a></span>USBDX_buf_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_buf_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint8_t *usbd, const uint8_t *app, uint16_t len)&#160;</td>
          <td class="paramname"><em>buf_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>usbd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c631177e850d6450f69202e1a084550" name="a0c631177e850d6450f69202e1a084550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c631177e850d6450f69202e1a084550">&#9670;&nbsp;</a></span>USBDX_force_acquire_urb_for_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a> * USBDX_force_acquire_urb_for_app </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns a URB. </p>
<p >Application can choose to acquire URB even if it is still held by USBD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>The pipe whose data to be transferred to/from USBD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A URB. </dd></dl>

</div>
</div>
<a id="a8c2fa39bb6dd7e144fa72d70cf213424" name="a8c2fa39bb6dd7e144fa72d70cf213424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2fa39bb6dd7e144fa72d70cf213424">&#9670;&nbsp;</a></span>USBDX_get_app_urbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * USBDX_get_app_urbs </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To get more than one URBs for application. </p>
<p >Application to use this API to get more than one URB from the USBD. </p><dl class="section attention"><dt>Attention</dt><dd>This function should be called to obtain the length before copying and submitting the URBs through usbd_sumit_urbs(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>The pipe for which the data transfer is needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of the data that the application wants to transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the URBs that is available for application usage. </dd></dl>

</div>
</div>
<a id="a0a5444f7d25fd7a46ca71e0bcf45f6fd" name="a0a5444f7d25fd7a46ca71e0bcf45f6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5444f7d25fd7a46ca71e0bcf45f6fd">&#9670;&nbsp;</a></span>USBDX_pipe_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBDX_pipe_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a> *&#160;</td>
          <td class="paramname"><em>urbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>urb_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the URB pipe for data transfer. </p>
<p >Application provides a linear space buffer to USBD. An array of URBs is initialised by USBD, dividing the linear space into small chunks (512 bytes for HS, 64 bytes for FS). Pipe is initialised by USBD, pointing to its own URBs. Each Endpoint is represented by a pipe structure. Application can create multiple pipes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>Pipe structure that gets initialised by USBD upon creation of pipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>USBD_ENDPOINT_NUMBER for which a pipe has to be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>USBD_ENDPOINT_NUMBER with MSB bit set incase of IN Endpoints. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">urbs</td><td>URB structure that gets initialised by USBD upon creation of pipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufs</td><td>A linear buffer to be passed by the application which gets divided into URBs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">urb_count</td><td>number of URBs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'True' if pipe is created. 'False' if the input parameters are invalid. </dd></dl>

</div>
</div>
<a id="a319ae19b9f42b26d47268ef9be67e81f" name="a319ae19b9f42b26d47268ef9be67e81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319ae19b9f42b26d47268ef9be67e81f">&#9670;&nbsp;</a></span>USBDX_pipe_isr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_pipe_isr </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pipe_bitfields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous data transfer in USBDX. </p>
<p >Defined as a weak function in USBD. Note: !!! Application need to implement this function !!! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pipe_bitfields</td><td>Bits corresponding to Endpoint URBDX_pipe for which USBDX_pipe_process has to be called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab4866f18652ee4acb2ca073153bf3dd" name="aab4866f18652ee4acb2ca073153bf3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4866f18652ee4acb2ca073153bf3dd">&#9670;&nbsp;</a></span>USBDX_pipe_isr_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_pipe_isr_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container function before processing pipes. </p>
<p >Defined as a weak function in USBD. Note: !!! Application can implement this function !!! </p>

</div>
</div>
<a id="a8d3168375907a3ecd2d3da64b4243aae" name="a8d3168375907a3ecd2d3da64b4243aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3168375907a3ecd2d3da64b4243aae">&#9670;&nbsp;</a></span>USBDX_pipe_isr_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_pipe_isr_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container function after processing pipes. </p>
<p >Defined as a weak function in USBD. Note: !!! Application can implement this function !!! </p>

</div>
</div>
<a id="a6eeaa38efaede81c10cdccb73859839f" name="a6eeaa38efaede81c10cdccb73859839f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eeaa38efaede81c10cdccb73859839f">&#9670;&nbsp;</a></span>USBDX_pipe_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_pipe_process </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The given pipe is processed to transfer the data to/from USBD hardware endpoint. </p>
<p >The given pipe is processed to transfer the data to/from USBD hardware endpoint. </p><dl class="section attention"><dt>Attention</dt><dd>This function has to be called from <a class="el" href="ft900__usbdx_8h.html#a319ae19b9f42b26d47268ef9be67e81f" title="Asynchronous data transfer in USBDX.">USBDX_pipe_isr()</a> implemented by the application. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>The pipe whose data to be transferred to/from USBD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3de006e6c851ea4929881798485ed32" name="ae3de006e6c851ea4929881798485ed32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3de006e6c851ea4929881798485ed32">&#9670;&nbsp;</a></span>USBDX_pipe_purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_pipe_purge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To flush the pipe. </p>
<p >Purge the data in the the URBs for a given pipe </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>Pipe for which data to be purged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7982281df0dec3c78adc2ded6e152c98" name="a7982281df0dec3c78adc2ded6e152c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7982281df0dec3c78adc2ded6e152c98">&#9670;&nbsp;</a></span>USBDX_register_on_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_register_on_ready </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbdx_8h.html#add9df82e61e57ce4950d571941880883">USBDX_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To register callback function for USBD READY event. </p>
<p >Application shall call this API to register their callback function to get notified of when USBD is ready to process the URBs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>Pipe for which the callback function is associated to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Callback function to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89093272d9e88675b1a660afc3e1c270" name="a89093272d9e88675b1a660afc3e1c270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89093272d9e88675b1a660afc3e1c270">&#9670;&nbsp;</a></span>USBDX_register_on_underrun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_register_on_underrun </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ft900__usbdx_8h.html#add9df82e61e57ce4950d571941880883">USBDX_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To register callback function for USDB UNDERRUN event. </p>
<p >Application shall call this API to register their callback function to get notified of when USBD is underrunning when no data from application. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>Pipe for which the callback function is associated to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Callback function to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6222c099c5f593681c833b2c35c52ee" name="aa6222c099c5f593681c833b2c35c52ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6222c099c5f593681c833b2c35c52ee">&#9670;&nbsp;</a></span>USBDX_stream_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_stream_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint8_t *app, const uint8_t *usbd, uint16_t len)&#160;</td>
          <td class="paramname"><em>stream_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>usbd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c8b411a24a59d4c7568b91e02236be0" name="a7c8b411a24a59d4c7568b91e02236be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8b411a24a59d4c7568b91e02236be0">&#9670;&nbsp;</a></span>USBDX_stream_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_stream_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint8_t *usbd, const uint8_t *app, uint16_t len)&#160;</td>
          <td class="paramname"><em>stream_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>usbd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a753728d1b207d43b70a676c2e6670837" name="a753728d1b207d43b70a676c2e6670837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753728d1b207d43b70a676c2e6670837">&#9670;&nbsp;</a></span>USBDX_submit_urb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBDX_submit_urb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a> *&#160;</td>
          <td class="paramname"><em>urb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a URB to USBD. </p>
<p >Application fills the urb and submits to USBD through this API call. When a URB is submitted without filling, this will make USBD to send a ZLP. </p><dl class="section attention"><dt>Attention</dt><dd>This function should be protected by critical section since it is called from application's context. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>The pipe whose data to be transferred to/from USBD. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">urb</td><td>Filled URB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a013a4bbef771435d3f2b2ebec9fa8643" name="a013a4bbef771435d3f2b2ebec9fa8643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013a4bbef771435d3f2b2ebec9fa8643">&#9670;&nbsp;</a></span>USBDX_submit_urbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_u_s_b_d_x__urb.html">USBDX_urb</a> * USBDX_submit_urbs </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_u_s_b_d_x__pipe.html">USBDX_pipe</a> *&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To submit more than one URBs from application. </p>
<p >Application fills the URBs and submits to USBD through this API call. </p><dl class="section attention"><dt>Attention</dt><dd>This function should be protected by critical section since it is called from application's context. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pp</td><td>The pipe whose data to be transferred to/from USBD. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length must be equal or smaller than the length gotten from usbd_get_app_urbs(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next available URB </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 6 2023 14:42:03 for libft900 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
